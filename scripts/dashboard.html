<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HomeConnect Coffee Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background: #4caf50;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #f44336;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: #666;
        }

        .status-value {
            font-weight: 600;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .event-log {
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .event-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f9f9f9;
            border-left: 3px solid #667eea;
            border-radius: 3px;
        }

        .event-time {
            color: #999;
            font-size: 0.85em;
        }

        .event-type {
            font-weight: 600;
            color: #667eea;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>☕ HomeConnect Coffee Dashboard</h1>
            <p>
                <span class="status-indicator" id="connectionStatus"></span>
                <span id="connectionText">Verbinde...</span>
            </p>
        </header>

        <div class="grid">
            <div class="card">
                <h2>Live-Status</h2>
                <div id="liveStatus">
                    <div class="loading">Lade Status...</div>
                </div>
            </div>

            <div class="card">
                <h2>Aktives Programm</h2>
                <div id="activeProgram">
                    <div class="loading">Lade Programm...</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Programm-Nutzung</h2>
                <div class="chart-container">
                    <canvas id="programChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Tägliche Nutzung (letzte 7 Tage)</h2>
                <div class="chart-container">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Event-Log</h2>
                <div class="event-log" id="eventLog">
                    <div class="loading">Warte auf Events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Konfiguration
        const API_BASE = window.location.origin;
        const API_TOKEN = new URLSearchParams(window.location.search).get('token') || '';

        // Charts
        let programChart = null;
        let dailyChart = null;

        // EventSource für Live-Updates
        let eventSource = null;
        
        // Lazy Loading State
        let isLoadingMoreEvents = false;
        let hasMoreEvents = true;
        let oldestEventTimestamp = null;

        // Initialisierung
        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            setupInfiniteScroll();
            // Lade Daten - Initial Data zuerst, dann Event History
            loadInitialData().then(() => {
                // Event History nach Initial Data laden
                loadEventHistory();
            });
            connectEventStream();
            // Kein setInterval mehr - Updates kommen über Event-Stream
        });

        function initCharts() {
            // Programm-Nutzung Chart
            const programCtx = document.getElementById('programChart').getContext('2d');
            programChart = new Chart(programCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Anzahl',
                        data: [],
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });

            // Tägliche Nutzung Chart
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Nutzung pro Tag',
                        data: [],
                        borderColor: 'rgba(102, 126, 234, 1)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        async function loadInitialData() {
            try {
                // Status laden
                const statusUrl = API_TOKEN 
                    ? `${API_BASE}/api/status?token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/status`;
                const statusResponse = await fetch(statusUrl);
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    updateLiveStatus(statusData);
                } else {
                    // Fehler beim Laden des Status
                    console.error('Fehler beim Laden des Status:', statusResponse.status, statusResponse.statusText);
                    const liveStatusDiv = document.getElementById('liveStatus');
                    if (liveStatusDiv && liveStatusDiv.querySelector('.loading')) {
                        liveStatusDiv.innerHTML = `
                            <div class="error">Fehler beim Laden des Status (${statusResponse.status})</div>
                        `;
                    }
                }

                // History laden
                await loadHistory();
            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                // Zeige Fehler in der UI
                const liveStatusDiv = document.getElementById('liveStatus');
                if (liveStatusDiv) {
                    if (liveStatusDiv.querySelector('.loading')) {
                        liveStatusDiv.innerHTML = `
                            <div class="error">Fehler beim Laden: ${error.message}</div>
                        `;
                    }
                }
            }
        }

        function updateLiveStatus(data) {
            const liveStatusDiv = document.getElementById('liveStatus');
            
            // PowerState aus Settings extrahieren
            let powerState = 'Unbekannt';
            let operationState = 'Unbekannt';
            
            if (data.settings && data.settings.data && data.settings.data.settings) {
                data.settings.data.settings.forEach(setting => {
                    if (setting.key === 'BSH.Common.Setting.PowerState') {
                        powerState = setting.value.replace('BSH.Common.EnumType.PowerState.', '');
                    }
                });
            }
            
            // OperationState aus Status extrahieren
            if (data.status && data.status.data && data.status.data.status) {
                data.status.data.status.forEach(status => {
                    if (status.key === 'BSH.Common.Status.OperationState') {
                        operationState = status.value.replace('BSH.Common.EnumType.OperationState.', '');
                    }
                });
            }

            // Status-Items erstellen
            liveStatusDiv.innerHTML = `
                <div class="status-item">
                    <span class="status-label">Power State:</span>
                    <span class="status-value">${powerState}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Operation State:</span>
                    <span class="status-value">${operationState}</span>
                </div>
            `;

            // Aktives Programm
            const activeProgramDiv = document.getElementById('activeProgram');
            if (data.programs && data.programs.active && data.programs.active.data) {
                const program = data.programs.active.data;
                const programKey = program.key || 'Kein Programm';
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Programm:</span>
                        <span class="status-value">${programKey.replace('ConsumerProducts.CoffeeMaker.Program.', '')}</span>
                    </div>
                `;
            } else {
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Programm:</span>
                        <span class="status-value">Kein aktives Programm</span>
                    </div>
                `;
            }
        }

        async function loadHistory() {
            try {
                // Programm-Zählungen
                const countsUrl = API_TOKEN
                    ? `${API_BASE}/api/history?program_counts=1&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?program_counts=1`;
                const countsResponse = await fetch(countsUrl);
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    updateProgramChart(countsData.program_counts || {});
                }

                // Tägliche Nutzung
                const dailyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?daily_usage=1&days=7&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?daily_usage=1&days=7`;
                const dailyResponse = await fetch(dailyUrl);
                if (dailyResponse.ok) {
                    const dailyData = await dailyResponse.json();
                    updateDailyChart(dailyData.daily_usage || {});
                }
            } catch (error) {
                console.error('Fehler beim Laden der History:', error);
            }
        }

        async function loadEventHistory(beforeTimestamp = null) {
            if (isLoadingMoreEvents) {
                return; // Verhindere mehrfaches gleichzeitiges Laden
            }
            
            try {
                isLoadingMoreEvents = true;
                
                // Lade initial 20 Events, beim Nachladen weitere 20
                const limit = beforeTimestamp ? 20 : 20;
                let historyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?limit=${limit}&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?limit=${limit}`;
                
                if (beforeTimestamp) {
                    historyUrl += `&before_timestamp=${encodeURIComponent(beforeTimestamp)}`;
                }
                
                const historyResponse = await fetch(historyUrl);
                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    const events = historyData.history || [];
                    
                    const eventLog = document.getElementById('eventLog');
                    
                    // Initial Load: Leere Event-Log
                    if (!beforeTimestamp) {
                        if (eventLog.querySelector('.loading')) {
                            eventLog.innerHTML = '';
                        }
                        oldestEventTimestamp = null;
                    }
                    
                    if (events.length === 0) {
                        if (!beforeTimestamp) {
                            eventLog.innerHTML = '<div class="loading">Noch keine Events gespeichert</div>';
                        } else {
                            // Keine weiteren Events
                            hasMoreEvents = false;
                            removeLoadingIndicator();
                        }
                    } else {
                        // Events werden chronologisch zurückgegeben (älteste zuerst)
                        // Für Anzeige: Neueste zuerst (oben), also umkehren beim Initial Load
                        // Beim Nachladen: Events am Ende hinzufügen (sind bereits chronologisch sortiert)
                        
                        if (!beforeTimestamp) {
                            // Initial Load: Neueste zuerst anzeigen (umkehren)
                            const reversedEvents = [...events].reverse();
                            reversedEvents.forEach(event => {
                                addEventToLogFromHistory(event, true); // true = oben einfügen
                            });
                            
                            // Speichere Timestamp des ältesten Events (für Nachladen)
                            if (events.length > 0) {
                                oldestEventTimestamp = events[0].timestamp; // Ältestes Event
                            }
                        } else {
                            // Nachladen: Events am Ende hinzufügen (chronologisch älteste zuerst)
                            events.forEach(event => {
                                addEventToLogFromHistory(event, false); // false = am Ende hinzufügen
                            });
                            
                            // Aktualisiere Timestamp des ältesten geladenen Events
                            if (events.length > 0) {
                                oldestEventTimestamp = events[0].timestamp;
                            }
                        }
                        
                        // Wenn weniger Events als Limit zurückgegeben wurden, gibt es keine weiteren
                        if (events.length < limit) {
                            hasMoreEvents = false;
                        }
                    }
                }
            } catch (error) {
                console.error('Fehler beim Laden der Event-Historie:', error);
            } finally {
                isLoadingMoreEvents = false;
                removeLoadingIndicator();
            }
        }
        
        function setupInfiniteScroll() {
            const eventLog = document.getElementById('eventLog');
            
            eventLog.addEventListener('scroll', () => {
                // Prüfe ob User nahe am Ende ist (100px vor Ende)
                const scrollTop = eventLog.scrollTop;
                const scrollHeight = eventLog.scrollHeight;
                const clientHeight = eventLog.clientHeight;
                
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    // Lade weitere Events, wenn noch welche vorhanden sind
                    if (hasMoreEvents && !isLoadingMoreEvents && oldestEventTimestamp) {
                        showLoadingIndicator();
                        loadEventHistory(oldestEventTimestamp);
                    }
                }
            });
        }
        
        function showLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            // Entferne vorhandenen Loading-Indikator
            const existing = eventLog.querySelector('.loading-more');
            if (existing) {
                existing.remove();
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading loading-more';
            loadingDiv.textContent = 'Lade weitere Events...';
            eventLog.appendChild(loadingDiv);
        }
        
        function removeLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        function addEventToLogFromHistory(event, prepend = false) {
            const eventLog = document.getElementById('eventLog');
            
            // Entferne Loading-Indikator falls vorhanden
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
            
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Parse Timestamp
            let timestamp = 'Unbekannt';
            try {
                const eventDate = new Date(event.timestamp);
                timestamp = eventDate.toLocaleString('de-DE', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } catch (e) {
                timestamp = event.timestamp || 'Unbekannt';
            }
            
            const eventType = (event.type || 'UNKNOWN').toUpperCase();
            const eventData = event.data || {};
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(eventData, null, 2)}</div>
            `;

            if (prepend) {
                eventLog.insertBefore(eventItem, eventLog.firstChild);
            } else {
                eventLog.appendChild(eventItem);
            }
        }

        function updateProgramChart(counts) {
            if (!counts || Object.keys(counts).length === 0) {
                // Keine Daten - zeige Platzhalter
                programChart.data.labels = ['Noch keine Daten'];
                programChart.data.datasets[0].data = [0];
                programChart.update();
                return;
            }

            const labels = Object.keys(counts).map(key => 
                key.replace('ConsumerProducts.CoffeeMaker.Program.', '')
            );
            const values = Object.values(counts);

            programChart.data.labels = labels;
            programChart.data.datasets[0].data = values;
            programChart.update();
        }

        function updateDailyChart(dailyUsage) {
            if (!dailyUsage || Object.keys(dailyUsage).length === 0) {
                // Keine Daten - zeige Platzhalter
                dailyChart.data.labels = ['Noch keine Daten'];
                dailyChart.data.datasets[0].data = [0];
                dailyChart.update();
                return;
            }

            // Sortiere nach Datum
            const sortedDates = Object.keys(dailyUsage).sort();
            const values = sortedDates.map(date => dailyUsage[date]);

            dailyChart.data.labels = sortedDates;
            dailyChart.data.datasets[0].data = values;
            dailyChart.update();
        }

        function connectEventStream() {
            const eventsUrl = API_TOKEN
                ? `${API_BASE}/events?token=${encodeURIComponent(API_TOKEN)}`
                : `${API_BASE}/events`;

            eventSource = new EventSource(eventsUrl);

            eventSource.onopen = () => {
                document.getElementById('connectionStatus').classList.remove('disconnected');
                document.getElementById('connectionText').textContent = 'Verbunden';
            };

            eventSource.onerror = () => {
                document.getElementById('connectionStatus').classList.add('disconnected');
                document.getElementById('connectionText').textContent = 'Verbindung getrennt';
                
                // Reconnect nach 3 Sekunden
                setTimeout(() => {
                    if (eventSource) {
                        eventSource.close();
                    }
                    connectEventStream();
                }, 3000);
            };

            eventSource.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('message', data);
                } catch (e) {
                    console.error('Fehler beim Parsen von Event:', e);
                }
            });

            eventSource.addEventListener('STATUS', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('STATUS', data);
                    // Kein loadInitialData() mehr - Updates kommen über Event-Stream
                    // Status wird beim Initial Load geladen, danach nur noch via Events aktualisiert
                } catch (e) {
                    console.error('Fehler beim Parsen von STATUS-Event:', e);
                }
            });

            eventSource.addEventListener('EVENT', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('EVENT', data);
                    loadHistory(); // History neu laden
                } catch (e) {
                    console.error('Fehler beim Parsen von EVENT:', e);
                }
            });

            eventSource.addEventListener('connected', (event) => {
                const data = JSON.parse(event.data);
                addEventToLog('system', data);
            });
        }

        function addEventToLog(type, data) {
            const eventLog = document.getElementById('eventLog');
            
            // Entferne Loading-Message
            if (eventLog.querySelector('.loading') && !eventLog.querySelector('.event-item')) {
                eventLog.innerHTML = '';
            }

            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            const timestamp = new Date().toLocaleTimeString('de-DE');
            const eventType = type.toUpperCase();
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(data, null, 2)}</div>
            `;

            // Live-Events immer oben einfügen
            eventLog.insertBefore(eventItem, eventLog.firstChild);

            // Begrenze auf 100 Events im DOM (für Performance)
            while (eventLog.children.length > 100) {
                const lastChild = eventLog.lastChild;
                if (lastChild && !lastChild.classList.contains('loading-more')) {
                    eventLog.removeChild(lastChild);
                } else {
                    break; // Nicht mehr Events entfernen, wenn Loading-Indikator erreicht
                }
            }
        }

        // Cleanup beim Schließen
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>

