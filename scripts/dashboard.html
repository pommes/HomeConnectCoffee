<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HomeConnect Coffee Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background: #4caf50;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #f44336;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: #666;
        }

        .status-value {
            font-weight: 600;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .event-log {
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .event-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f9f9f9;
            border-left: 3px solid #667eea;
            border-radius: 3px;
        }

        .event-time {
            color: #999;
            font-size: 0.85em;
        }

        .event-type {
            font-weight: 600;
            color: #667eea;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>â˜• HomeConnect Coffee Dashboard</h1>
            <p>
                <span class="status-indicator" id="connectionStatus"></span>
                <span id="connectionText">Connecting...</span>
            </p>
        </header>

        <div class="grid">
            <div class="card">
                <h2>Live Status</h2>
                <div id="liveStatus">
                    <div class="loading">Loading status...</div>
                </div>
            </div>

            <div class="card">
                <h2>Active Program</h2>
                <div id="activeProgram">
                    <div class="loading">Loading program...</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Program Usage</h2>
                <div class="chart-container">
                    <canvas id="programChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Daily Usage (last 7 days)</h2>
                <div class="chart-container">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Event Log</h2>
                <div class="event-log" id="eventLog">
                    <div class="loading">Waiting for events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = window.location.origin;
        const API_TOKEN = new URLSearchParams(window.location.search).get('token') || '';

        // Charts
        let programChart = null;
        let dailyChart = null;

        // EventSource for live updates
        let eventSource = null;
        
        // Lazy loading state
        let isLoadingMoreEvents = false;
        let hasMoreEvents = true;
        let oldestEventTimestamp = null;

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            setupInfiniteScroll();
            // Load data - initial data first, then event history
            loadInitialData().then(() => {
                // Load event history after initial data
                loadEventHistory();
            });
            connectEventStream();
            // No setInterval anymore - updates come via event stream
        });

        function initCharts() {
            // Program usage chart
            const programCtx = document.getElementById('programChart').getContext('2d');
            programChart = new Chart(programCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Count',
                        data: [],
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });

            // Daily usage chart
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Usage per day',
                        data: [],
                        borderColor: 'rgba(102, 126, 234, 1)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        async function loadInitialData() {
            try {
                // Load status
                const statusUrl = API_TOKEN 
                    ? `${API_BASE}/api/status?token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/status`;
                const statusResponse = await fetch(statusUrl);
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    updateLiveStatus(statusData);
                } else {
                    // Handle different error cases
                    const liveStatusDiv = document.getElementById('liveStatus');
                    if (liveStatusDiv && liveStatusDiv.querySelector('.loading')) {
                        if (statusResponse.status === 503) {
                            // Service Unavailable - device is offline
                            liveStatusDiv.innerHTML = `
                                <div class="status-item">
                                    <span class="status-label">Status:</span>
                                    <span class="status-value" style="color: #ff9800;">Device offline</span>
                                </div>
                                <div class="status-item">
                                    <span class="status-label">Operation State:</span>
                                    <span class="status-value">Unreachable</span>
                                </div>
                            `;
                        } else {
                            // Other errors
                            console.error('Error loading status:', statusResponse.status, statusResponse.statusText);
                            liveStatusDiv.innerHTML = `
                                <div class="error">Error loading status (${statusResponse.status})</div>
                            `;
                        }
                    }
                }

                // Load history
                await loadHistory();
            } catch (error) {
                console.error('Error loading data:', error);
                // Show error in UI
                const liveStatusDiv = document.getElementById('liveStatus');
                if (liveStatusDiv) {
                    if (liveStatusDiv.querySelector('.loading')) {
                        liveStatusDiv.innerHTML = `
                            <div class="error">Error loading: ${error.message}</div>
                        `;
                    }
                }
            }
        }

        function updateLiveStatus(data) {
            const liveStatusDiv = document.getElementById('liveStatus');
            
            // Extract PowerState from settings
            let powerState = 'Unknown';
            let operationState = 'Unknown';
            
            if (data.settings && data.settings.data && data.settings.data.settings) {
                data.settings.data.settings.forEach(setting => {
                    if (setting.key === 'BSH.Common.Setting.PowerState') {
                        powerState = setting.value.replace('BSH.Common.EnumType.PowerState.', '');
                    }
                });
            }
            
            // Extract OperationState from status
            if (data.status && data.status.data && data.status.data.status) {
                data.status.data.status.forEach(status => {
                    if (status.key === 'BSH.Common.Status.OperationState') {
                        operationState = status.value.replace('BSH.Common.EnumType.OperationState.', '');
                    }
                });
            }

            // Create status items
            liveStatusDiv.innerHTML = `
                <div class="status-item">
                    <span class="status-label">Power State:</span>
                    <span class="status-value">${powerState}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Operation State:</span>
                    <span class="status-value">${operationState}</span>
                </div>
            `;

            // Active program
            const activeProgramDiv = document.getElementById('activeProgram');
            if (data.programs && data.programs.active && data.programs.active.data) {
                const program = data.programs.active.data;
                const programKey = program.key || 'No program';
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Program:</span>
                        <span class="status-value">${programKey.replace('ConsumerProducts.CoffeeMaker.Program.', '')}</span>
                    </div>
                `;
            } else {
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Program:</span>
                        <span class="status-value">No active program</span>
                    </div>
                `;
            }
        }

        async function loadHistory() {
            try {
                // Program counts
                const countsUrl = API_TOKEN
                    ? `${API_BASE}/api/history?program_counts=1&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?program_counts=1`;
                const countsResponse = await fetch(countsUrl);
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    updateProgramChart(countsData.program_counts || {});
                }

                // Daily usage
                const dailyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?daily_usage=1&days=7&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?daily_usage=1&days=7`;
                const dailyResponse = await fetch(dailyUrl);
                if (dailyResponse.ok) {
                    const dailyData = await dailyResponse.json();
                    updateDailyChart(dailyData.daily_usage || {});
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        async function loadEventHistory(beforeTimestamp = null) {
            if (isLoadingMoreEvents) {
                return; // Prevent multiple simultaneous loads
            }
            
            try {
                isLoadingMoreEvents = true;
                
                // Load initial 20 events, 20 more when loading more
                const limit = beforeTimestamp ? 20 : 20;
                let historyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?limit=${limit}&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?limit=${limit}`;
                
                if (beforeTimestamp) {
                    historyUrl += `&before_timestamp=${encodeURIComponent(beforeTimestamp)}`;
                }
                
                const historyResponse = await fetch(historyUrl);
                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    const events = historyData.history || [];
                    
                    const eventLog = document.getElementById('eventLog');
                    
                    // Initial load: clear event log
                    if (!beforeTimestamp) {
                        if (eventLog.querySelector('.loading')) {
                            eventLog.innerHTML = '';
                        }
                        oldestEventTimestamp = null;
                    }
                    
                    if (events.length === 0) {
                        if (!beforeTimestamp) {
                            eventLog.innerHTML = '<div class="loading">No events stored yet</div>';
                        } else {
                            // No more events
                            hasMoreEvents = false;
                            removeLoadingIndicator();
                        }
                    } else {
                        // Events are returned chronologically (oldest first)
                        // For display: newest first (top), so reverse on initial load
                        // When loading more: add events at end (already chronologically sorted)
                        
                        if (!beforeTimestamp) {
                            // Initial load: show newest first (reverse)
                            const reversedEvents = [...events].reverse();
                            reversedEvents.forEach(event => {
                                addEventToLogFromHistory(event, true); // true = insert at top
                            });
                            
                            // Store timestamp of oldest event (for loading more)
                            if (events.length > 0) {
                                oldestEventTimestamp = events[0].timestamp; // Oldest event
                            }
                        } else {
                            // Load more: add events at end (chronologically oldest first)
                            events.forEach(event => {
                                addEventToLogFromHistory(event, false); // false = add at end
                            });
                            
                            // Update timestamp of oldest loaded event
                            if (events.length > 0) {
                                oldestEventTimestamp = events[0].timestamp;
                            }
                        }
                        
                        // If fewer events than limit were returned, there are no more
                        if (events.length < limit) {
                            hasMoreEvents = false;
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading event history:', error);
            } finally {
                isLoadingMoreEvents = false;
                removeLoadingIndicator();
            }
        }
        
        function setupInfiniteScroll() {
            const eventLog = document.getElementById('eventLog');
            
            eventLog.addEventListener('scroll', () => {
                // Check if user is near the end (100px before end)
                const scrollTop = eventLog.scrollTop;
                const scrollHeight = eventLog.scrollHeight;
                const clientHeight = eventLog.clientHeight;
                
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    // Load more events if there are any
                    if (hasMoreEvents && !isLoadingMoreEvents && oldestEventTimestamp) {
                        showLoadingIndicator();
                        loadEventHistory(oldestEventTimestamp);
                    }
                }
            });
        }
        
        function showLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            // Remove existing loading indicator
            const existing = eventLog.querySelector('.loading-more');
            if (existing) {
                existing.remove();
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading loading-more';
            loadingDiv.textContent = 'Loading more events...';
            eventLog.appendChild(loadingDiv);
        }
        
        function removeLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        function addEventToLogFromHistory(event, prepend = false) {
            const eventLog = document.getElementById('eventLog');
            
            // Remove loading indicator if present
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
            
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Parse timestamp
            let timestamp = 'Unknown';
            try {
                const eventDate = new Date(event.timestamp);
                // Format as ISO 8601: YYYY-MM-DDTHH:mm:ss
                timestamp = eventDate.toISOString().replace('T', ' ').substring(0, 19);
            } catch (e) {
                timestamp = event.timestamp || 'Unknown';
            }
            
            const eventType = (event.type || 'UNKNOWN').toUpperCase();
            const eventData = event.data || {};
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(eventData, null, 2)}</div>
            `;

            if (prepend) {
                eventLog.insertBefore(eventItem, eventLog.firstChild);
            } else {
                eventLog.appendChild(eventItem);
            }
        }

        function updateProgramChart(counts) {
            if (!counts || Object.keys(counts).length === 0) {
                // No data - show placeholder
                programChart.data.labels = ['No data yet'];
                programChart.data.datasets[0].data = [0];
                programChart.update();
                return;
            }

            const labels = Object.keys(counts).map(key => 
                key.replace('ConsumerProducts.CoffeeMaker.Program.', '')
            );
            const values = Object.values(counts);

            programChart.data.labels = labels;
            programChart.data.datasets[0].data = values;
            programChart.update();
        }

        function updateDailyChart(dailyUsage) {
            if (!dailyUsage || Object.keys(dailyUsage).length === 0) {
                // No data - show placeholder
                dailyChart.data.labels = ['No data yet'];
                dailyChart.data.datasets[0].data = [0];
                dailyChart.update();
                return;
            }

            // Sort by date
            const sortedDates = Object.keys(dailyUsage).sort();
            const values = sortedDates.map(date => dailyUsage[date]);

            dailyChart.data.labels = sortedDates;
            dailyChart.data.datasets[0].data = values;
            dailyChart.update();
        }

        function connectEventStream() {
            const eventsUrl = API_TOKEN
                ? `${API_BASE}/events?token=${encodeURIComponent(API_TOKEN)}`
                : `${API_BASE}/events`;

            eventSource = new EventSource(eventsUrl);

            eventSource.onopen = () => {
                document.getElementById('connectionStatus').classList.remove('disconnected');
                document.getElementById('connectionText').textContent = 'Connected';
            };

            eventSource.onerror = () => {
                document.getElementById('connectionStatus').classList.add('disconnected');
                document.getElementById('connectionText').textContent = 'Connection lost';
                
                // Reconnect after 3 seconds
                setTimeout(() => {
                    if (eventSource) {
                        eventSource.close();
                    }
                    connectEventStream();
                }, 3000);
            };

            eventSource.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('message', data);
                } catch (e) {
                    console.error('Error parsing event:', e);
                }
            });

            eventSource.addEventListener('STATUS', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('STATUS', data);
                    // No loadInitialData() anymore - updates come via event stream
                    // Status is loaded on initial load, then only updated via events
                } catch (e) {
                    console.error('Error parsing STATUS event:', e);
                }
            });

            eventSource.addEventListener('EVENT', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('EVENT', data);
                    loadHistory(); // Reload history
                } catch (e) {
                    console.error('Error parsing EVENT:', e);
                }
            });

            eventSource.addEventListener('connected', (event) => {
                const data = JSON.parse(event.data);
                addEventToLog('system', data);
            });
        }

        function addEventToLog(type, data) {
            const eventLog = document.getElementById('eventLog');
            
            // Remove loading message
            if (eventLog.querySelector('.loading') && !eventLog.querySelector('.event-item')) {
                eventLog.innerHTML = '';
            }

            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Format as ISO 8601: YYYY-MM-DDTHH:mm:ss
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
            const eventType = type.toUpperCase();
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(data, null, 2)}</div>
            `;

            // Always insert live events at top
            eventLog.insertBefore(eventItem, eventLog.firstChild);

            // Limit to 100 events in DOM (for performance)
            while (eventLog.children.length > 100) {
                const lastChild = eventLog.lastChild;
                if (lastChild && !lastChild.classList.contains('loading-more')) {
                    eventLog.removeChild(lastChild);
                } else {
                    break; // Don't remove more events if loading indicator is reached
                }
            }
        }

        // Cleanup on close
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>

