<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HomeConnect Coffee Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background: #4caf50;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #f44336;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: #666;
        }

        .status-value {
            font-weight: 600;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .event-log {
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .event-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f9f9f9;
            border-left: 3px solid #667eea;
            border-radius: 3px;
        }

        .event-time {
            color: #999;
            font-size: 0.85em;
        }

        .event-type {
            font-weight: 600;
            color: #667eea;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        /* Progress bar styles */
        .progress-container {
            margin-top: 15px;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .progress-bar-container {
            width: 100%;
            height: 24px;
            background-color: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85em;
        }

        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 0.85em;
            color: #333;
            z-index: 1;
        }

        .progress-bar.active {
            animation: progress-pulse 1.5s ease-in-out infinite;
        }

        @keyframes progress-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>☕ HomeConnect Coffee Dashboard</h1>
            <p>
                <span class="status-indicator" id="connectionStatus"></span>
                <span id="connectionText">Connecting...</span>
            </p>
        </header>

        <div class="grid">
            <div class="card">
                <h2>Live Status</h2>
                <div id="liveStatus">
                    <div class="loading">Loading status...</div>
                </div>
            </div>

            <div class="card">
                <h2>Active Program</h2>
                <div id="activeProgram">
                    <div class="loading">Loading program...</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Program Usage</h2>
                <div class="chart-container">
                    <canvas id="programChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Daily Usage (last 7 days)</h2>
                <div class="chart-container">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Event Log</h2>
                <div class="event-log" id="eventLog">
                    <div class="loading">Waiting for events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = window.location.origin;
        const API_TOKEN = new URLSearchParams(window.location.search).get('token') || '';

        // Charts
        let programChart = null;
        let dailyChart = null;

        // EventSource for live updates
        let eventSource = null;
        
        // Lazy loading state
        let isLoadingMoreEvents = false;
        let hasMoreEvents = true;
        let oldestEventTimestamp = null;

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            setupInfiniteScroll();
            // Load data - initial data first, then event history
            loadInitialData().then(() => {
                // Load event history after initial data
                loadEventHistory();
            });
            connectEventStream();
            // No setInterval anymore - updates come via event stream
        });

        function initCharts() {
            // Program usage chart
            const programCtx = document.getElementById('programChart').getContext('2d');
            programChart = new Chart(programCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Count',
                        data: [],
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });

            // Daily usage chart
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Usage per day',
                        data: [],
                        borderColor: 'rgba(102, 126, 234, 1)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        async function loadInitialData() {
            try {
                // Load status
                const statusUrl = API_TOKEN 
                    ? `${API_BASE}/api/status?token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/status`;
                const statusResponse = await fetch(statusUrl);
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    updateLiveStatus(statusData);
                } else {
                    // Handle different error cases
                    const liveStatusDiv = document.getElementById('liveStatus');
                    if (liveStatusDiv && liveStatusDiv.querySelector('.loading')) {
                        if (statusResponse.status === 503) {
                            // Service Unavailable - device is offline
                            liveStatusDiv.innerHTML = `
                                <div class="status-item">
                                    <span class="status-label">Status:</span>
                                    <span class="status-value" style="color: #ff9800;">Device offline</span>
                                </div>
                                <div class="status-item">
                                    <span class="status-label">Operation State:</span>
                                    <span class="status-value">Unreachable</span>
                                </div>
                            `;
                        } else {
                            // Other errors
                            console.error('Error loading status:', statusResponse.status, statusResponse.statusText);
                            liveStatusDiv.innerHTML = `
                                <div class="error">Error loading status (${statusResponse.status})</div>
                            `;
                        }
                    }
                }

                // Load history
                await loadHistory();
            } catch (error) {
                console.error('Error loading data:', error);
                // Show error in UI
                const liveStatusDiv = document.getElementById('liveStatus');
                if (liveStatusDiv) {
                    if (liveStatusDiv.querySelector('.loading')) {
                        liveStatusDiv.innerHTML = `
                            <div class="error">Error loading: ${error.message}</div>
                        `;
                    }
                }
            }
        }

        function formatProgramName(programKey) {
            if (!programKey || programKey === 'No program') {
                return 'No active program';
            }
            
            // Remove common prefixes (in order of specificity, case-insensitive)
            let name = programKey
                .replace(/ConsumerProducts\.CoffeeMaker\.Program\./gi, '')
                .replace(/BSH\.Common\.Program\./gi, '')
                .replace(/CleaningModes\./gi, '')
                .replace(/Beverage\./gi, ''); // Remove Beverage prefix (e.g., "Beverage.Espresso" or "Beverage.espresso")
            
            // Normalize to lowercase for case-insensitive mapping lookup
            const normalizedName = name.toLowerCase();
            
            // Mapping for common program names (case-insensitive lookup)
            const programMap = {
                // Coffee Maker Programs
                'espresso': 'Espresso',
                'coffee': 'Cafè Crema', // Coffee program maps to Cafè Crema
                'cappuccino': 'Cappuccino',
                'lattemacchiato': 'Latte Macchiato',
                'caffelatte': 'Caffè Latte',
                'americano': 'Americano',
                'hotwater': 'Hot Water',
                'hotmilk': 'Hot Milk',
                'milkfoam': 'Milk Foam',
                'ristretto': 'Ristretto',
                'lungo': 'Lungo',
                
                // Cleaning Modes
                'applianceonrinsing': 'Rinsing',
                'applianceondescaling': 'Descaling',
                'applianceoncleaning': 'Cleaning',
                
                // Common States
                'standby': 'Standby',
                'ready': 'Ready',
                'running': 'Running',
                'finished': 'Finished',
                'aborted': 'Aborted',
                'error': 'Error',
            };
            
            // Check if we have a direct mapping (case-insensitive)
            if (programMap[normalizedName]) {
                return programMap[normalizedName];
            }
            
            // Convert camelCase/PascalCase to readable format
            // e.g., "LatteMacchiato" -> "Latte Macchiato"
            name = name.replace(/([A-Z])/g, ' $1').trim();
            
            // Capitalize first letter of each word
            return name.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        function updateLiveStatus(data) {
            const liveStatusDiv = document.getElementById('liveStatus');
            
            // Extract PowerState from settings
            let powerState = 'Unknown';
            let operationState = 'Unknown';
            
            if (data.settings && data.settings.data && data.settings.data.settings) {
                data.settings.data.settings.forEach(setting => {
                    if (setting.key === 'BSH.Common.Setting.PowerState') {
                        powerState = setting.value.replace('BSH.Common.EnumType.PowerState.', '');
                    }
                });
            }
            
            // Extract OperationState from status
            if (data.status && data.status.data && data.status.data.status) {
                data.status.data.status.forEach(status => {
                    if (status.key === 'BSH.Common.Status.OperationState') {
                        operationState = status.value.replace('BSH.Common.EnumType.OperationState.', '');
                    }
                });
            }

            // Create status items
            liveStatusDiv.innerHTML = `
                <div class="status-item">
                    <span class="status-label">Power State:</span>
                    <span class="status-value">${powerState}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Operation State:</span>
                    <span class="status-value">${operationState}</span>
                </div>
            `;

            // Active program
            const activeProgramDiv = document.getElementById('activeProgram');
            if (data.programs && data.programs.active && data.programs.active.data) {
                const program = data.programs.active.data;
                const programKey = program.key || 'No program';
                const programName = formatProgramName(programKey);
                
                // Check for progress in options
                let progressValue = null;
                if (program.options && Array.isArray(program.options)) {
                    const progressOption = program.options.find(opt => 
                        opt.key === 'BSH.Common.Option.ProgramProgress'
                    );
                    if (progressOption && progressOption.value !== undefined) {
                        progressValue = parseInt(progressOption.value);
                    }
                }
                
                let progressHTML = '';
                if (progressValue !== null && progressValue >= 0 && progressValue <= 100) {
                    progressHTML = `
                        <div class="progress-container">
                            <div class="progress-label">
                                <span>Progress</span>
                                <span>${progressValue}%</span>
                            </div>
                            <div class="progress-bar-container">
                                <div class="progress-bar active" style="width: ${progressValue}%"></div>
                                <div class="progress-text">${progressValue}%</div>
                            </div>
                        </div>
                    `;
                }
                
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Program:</span>
                        <span class="status-value">${programName}</span>
                    </div>
                    ${progressHTML}
                `;
            } else {
                // No active program - ensure progress bar is removed
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Program:</span>
                        <span class="status-value">No active program</span>
                    </div>
                `;
            }
        }

        function updateProgramProgress(progressValue) {
            const activeProgramDiv = document.getElementById('activeProgram');
            
            // Check if there's an active program (not "No active program")
            const programItem = activeProgramDiv.querySelector('.status-item');
            if (!programItem) {
                return; // No program item found
            }
            
            const programValueElement = programItem.querySelector('.status-value');
            if (!programValueElement || programValueElement.textContent.trim() === 'No active program') {
                // No active program - remove progress bar if it exists
                const progressContainer = activeProgramDiv.querySelector('.progress-container');
                if (progressContainer) {
                    progressContainer.remove();
                }
                return;
            }
            
            // Validate progress value
            if (progressValue === null || progressValue === undefined || isNaN(progressValue) || progressValue < 0 || progressValue > 100) {
                return;
            }
            
            // Update or create progress display
            let progressContainer = activeProgramDiv.querySelector('.progress-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-container';
                activeProgramDiv.appendChild(progressContainer);
            }
            
            progressContainer.innerHTML = `
                <div class="progress-label">
                    <span>Progress</span>
                    <span>${progressValue}%</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar active" style="width: ${progressValue}%"></div>
                    <div class="progress-text">${progressValue}%</div>
                </div>
            `;
        }

        async function loadHistory() {
            try {
                // Program counts
                const countsUrl = API_TOKEN
                    ? `${API_BASE}/api/history?program_counts=1&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?program_counts=1`;
                const countsResponse = await fetch(countsUrl);
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    updateProgramChart(countsData.program_counts || {});
                }

                // Daily usage
                const dailyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?daily_usage=1&days=7&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?daily_usage=1&days=7`;
                const dailyResponse = await fetch(dailyUrl);
                if (dailyResponse.ok) {
                    const dailyData = await dailyResponse.json();
                    updateDailyChart(dailyData.daily_usage || {});
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        async function loadEventHistory(beforeTimestamp = null) {
            if (isLoadingMoreEvents) {
                return; // Prevent multiple simultaneous loads
            }
            
            try {
                isLoadingMoreEvents = true;
                
                // Load initial 20 events, 20 more when loading more
                const limit = beforeTimestamp ? 20 : 20;
                let historyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?limit=${limit}&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?limit=${limit}`;
                
                if (beforeTimestamp) {
                    historyUrl += `&before_timestamp=${encodeURIComponent(beforeTimestamp)}`;
                }
                
                const historyResponse = await fetch(historyUrl);
                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    const events = historyData.history || [];
                    
                    const eventLog = document.getElementById('eventLog');
                    
                    // Initial load: clear event log
                    if (!beforeTimestamp) {
                        if (eventLog.querySelector('.loading')) {
                            eventLog.innerHTML = '';
                        }
                        oldestEventTimestamp = null;
                    }
                    
                    if (events.length === 0) {
                        if (!beforeTimestamp) {
                            eventLog.innerHTML = '<div class="loading">No events stored yet</div>';
                        } else {
                            // No more events
                            hasMoreEvents = false;
                            removeLoadingIndicator();
                        }
                    } else {
                        // Events are returned chronologically (oldest first)
                        // For display: newest first (top), so reverse on initial load
                        // When loading more: add events at end (already chronologically sorted)
                        
                        if (!beforeTimestamp) {
                            // Initial load: sort events by timestamp (newest first), then by value if timestamps are equal
                            const sortedEvents = [...events].sort((a, b) => {
                                const timestampA = new Date(a.timestamp).getTime();
                                const timestampB = new Date(b.timestamp).getTime();
                                
                                if (timestampB !== timestampA) {
                                    return timestampB - timestampA; // Descending order (newest first)
                                }
                                
                                // If timestamps are equal, try to sort by value (for ProgramProgress events)
                                const dataA = a.data || {};
                                const dataB = b.data || {};
                                
                                if (dataA.items && dataA.items[0] && dataA.items[0].value !== undefined &&
                                    dataB.items && dataB.items[0] && dataB.items[0].value !== undefined) {
                                    const valueA = parseInt(dataA.items[0].value) || 0;
                                    const valueB = parseInt(dataB.items[0].value) || 0;
                                    return valueB - valueA; // Descending order (higher value first)
                                }
                                
                                return 0; // Maintain insertion order
                            });
                            
                            // Create all event items and insert at once
                            const fragment = document.createDocumentFragment();
                            sortedEvents.forEach(event => {
                                const eventItem = document.createElement('div');
                                eventItem.className = 'event-item';
                                
                                const { timestamp, timestampValue } = extractTimestamp(event.data, event.timestamp);
                                eventItem.setAttribute('data-timestamp', timestampValue);
                                
                                const eventType = (event.type || 'UNKNOWN').toUpperCase();
                                const eventData = event.data || {};
                                
                                eventItem.innerHTML = `
                                    <div class="event-time">${timestamp}</div>
                                    <div class="event-type">${eventType}</div>
                                    <div>${JSON.stringify(eventData, null, 2)}</div>
                                `;
                                
                                fragment.appendChild(eventItem);
                            });
                            
                            eventLog.appendChild(fragment);
                            
                            // Store timestamp of oldest event (for loading more)
                            if (events.length > 0) {
                                // Find oldest event (lowest timestamp)
                                const oldestEvent = events.reduce((oldest, current) => {
                                    const oldestTime = new Date(oldest.timestamp).getTime();
                                    const currentTime = new Date(current.timestamp).getTime();
                                    return currentTime < oldestTime ? current : oldest;
                                });
                                oldestEventTimestamp = oldestEvent.timestamp;
                            }
                        } else {
                            // Load more: add events at end (chronologically oldest first)
                            events.forEach(event => {
                                addEventToLogFromHistory(event, false); // false = add at end
                            });
                            
                            // Update timestamp of oldest loaded event
                            if (events.length > 0) {
                                oldestEventTimestamp = events[0].timestamp;
                            }
                        }
                        
                        
                        // If fewer events than limit were returned, there are no more
                        if (events.length < limit) {
                            hasMoreEvents = false;
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading event history:', error);
            } finally {
                isLoadingMoreEvents = false;
                removeLoadingIndicator();
            }
        }
        
        function setupInfiniteScroll() {
            const eventLog = document.getElementById('eventLog');
            
            eventLog.addEventListener('scroll', () => {
                // Check if user is near the end (100px before end)
                const scrollTop = eventLog.scrollTop;
                const scrollHeight = eventLog.scrollHeight;
                const clientHeight = eventLog.clientHeight;
                
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    // Load more events if there are any
                    if (hasMoreEvents && !isLoadingMoreEvents && oldestEventTimestamp) {
                        showLoadingIndicator();
                        loadEventHistory(oldestEventTimestamp);
                    }
                }
            });
        }
        
        function showLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            // Remove existing loading indicator
            const existing = eventLog.querySelector('.loading-more');
            if (existing) {
                existing.remove();
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading loading-more';
            loadingDiv.textContent = 'Loading more events...';
            eventLog.appendChild(loadingDiv);
        }
        
        function removeLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        // Helper function to format date in local timezone (ISO-like format)
        function formatLocalTimestamp(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // Helper function to extract timestamp from event data
        function extractTimestamp(data, fallbackTimestamp = null) {
            let eventTimestamp = null;
            let timestampValue = Date.now();
            
            if (fallbackTimestamp) {
                // Use provided timestamp (for history events)
                try {
                    eventTimestamp = new Date(fallbackTimestamp);
                    timestampValue = eventTimestamp.getTime();
                } catch (e) {
                    // Invalid timestamp, use current time
                }
            } else if (data && typeof data === 'object') {
                // Extract from data (for live events)
                if (data.timestamp) {
                    if (typeof data.timestamp === 'number') {
                        timestampValue = data.timestamp < 10000000000 ? data.timestamp * 1000 : data.timestamp;
                        eventTimestamp = new Date(timestampValue);
                    } else {
                        eventTimestamp = new Date(data.timestamp);
                        timestampValue = eventTimestamp.getTime();
                    }
                } else if (data.items && Array.isArray(data.items)) {
                    for (const item of data.items) {
                        if (item.timestamp !== undefined && item.timestamp !== null) {
                            timestampValue = parseInt(item.timestamp) * 1000;
                            eventTimestamp = new Date(timestampValue);
                            break;
                        }
                    }
                }
            }
            
            if (!eventTimestamp || isNaN(eventTimestamp.getTime())) {
                eventTimestamp = new Date();
                timestampValue = Date.now();
            }
            
            // Format in local timezone instead of UTC
            const timestamp = formatLocalTimestamp(eventTimestamp);
            return { timestamp, timestampValue };
        }

        // Helper function to compare events for sorting (returns negative if a should come before b)
        function compareEvents(a, b) {
            const timestampA = parseInt(a.getAttribute('data-timestamp') || '0');
            const timestampB = parseInt(b.getAttribute('data-timestamp') || '0');
            
            if (timestampB !== timestampA) {
                return timestampB - timestampA; // Descending order (newest first)
            }
            
            // Same timestamp - try to sort by value (for ProgramProgress events)
            try {
                const lastDivA = a.querySelector('div:last-child');
                const lastDivB = b.querySelector('div:last-child');
                
                if (lastDivA && lastDivB) {
                    const dataA = JSON.parse(lastDivA.textContent);
                    const dataB = JSON.parse(lastDivB.textContent);
                    
                    if (dataA && dataA.items && Array.isArray(dataA.items) && dataA.items[0] && dataA.items[0].value !== undefined &&
                        dataB && dataB.items && Array.isArray(dataB.items) && dataB.items[0] && dataB.items[0].value !== undefined) {
                        const valueA = parseInt(dataA.items[0].value) || 0;
                        const valueB = parseInt(dataB.items[0].value) || 0;
                        return valueB - valueA; // Descending order (higher value first)
                    }
                }
            } catch (e) {
                // If parsing fails, maintain order
            }
            
            return 0; // Maintain insertion order
        }

        // Helper function to insert event at correct position
        function insertEventAtPosition(eventItem, timestampValue, eventData = null) {
            const eventLog = document.getElementById('eventLog');
            const existingEvents = Array.from(eventLog.querySelectorAll('.event-item'));
            
            for (let i = 0; i < existingEvents.length; i++) {
                const existingEvent = existingEvents[i];
                const existingTimestamp = parseInt(existingEvent.getAttribute('data-timestamp') || '0');
                
                if (timestampValue > existingTimestamp) {
                    eventLog.insertBefore(eventItem, existingEvent);
                    return true;
                } else if (timestampValue === existingTimestamp && eventData) {
                    // Same timestamp - try to sort by value
                    try {
                        const lastDivExisting = existingEvent.querySelector('div:last-child');
                        if (lastDivExisting) {
                            const dataExisting = JSON.parse(lastDivExisting.textContent);
                            
                            if (eventData.items && Array.isArray(eventData.items) && eventData.items[0] && eventData.items[0].value !== undefined &&
                                dataExisting && dataExisting.items && Array.isArray(dataExisting.items) && dataExisting.items[0] && dataExisting.items[0].value !== undefined) {
                                const valueNew = parseInt(eventData.items[0].value) || 0;
                                const valueExisting = parseInt(dataExisting.items[0].value) || 0;
                                
                                if (valueNew > valueExisting) {
                                    eventLog.insertBefore(eventItem, existingEvent);
                                    return true;
                                }
                            }
                        }
                    } catch (e) {
                        // If parsing fails, continue
                    }
                }
            }
            
            return false; // Not inserted, should be appended
        }

        function addEventToLogFromHistory(event, prepend = false) {
            const eventLog = document.getElementById('eventLog');
            
            // Remove loading indicator if present
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
            
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Extract timestamp
            const { timestamp, timestampValue } = extractTimestamp(event.data, event.timestamp);
            eventItem.setAttribute('data-timestamp', timestampValue);
            
            const eventType = (event.type || 'UNKNOWN').toUpperCase();
            const eventData = event.data || {};
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(eventData, null, 2)}</div>
            `;

            if (prepend) {
                // Insert at correct position (newest first)
                const inserted = insertEventAtPosition(eventItem, timestampValue, eventData);
                if (!inserted) {
                    // This is the newest event, insert at very top
                    if (eventLog.firstChild) {
                        eventLog.insertBefore(eventItem, eventLog.firstChild);
                    } else {
                        eventLog.appendChild(eventItem);
                    }
                }
            } else {
                // Append at end (for loading more events)
                const loadingIndicator = eventLog.querySelector('.loading-more');
                if (loadingIndicator) {
                    eventLog.insertBefore(eventItem, loadingIndicator);
                } else {
                    eventLog.appendChild(eventItem);
                }
            }
        }

        function updateProgramChart(counts) {
            if (!counts || Object.keys(counts).length === 0) {
                // No data - show placeholder
                programChart.data.labels = ['No data yet'];
                programChart.data.datasets[0].data = [0];
                programChart.update();
                return;
            }

            const labels = Object.keys(counts).map(key => 
                formatProgramName(key)
            );
            const values = Object.values(counts);

            programChart.data.labels = labels;
            programChart.data.datasets[0].data = values;
            programChart.update();
        }

        function updateDailyChart(dailyUsage) {
            if (!dailyUsage || Object.keys(dailyUsage).length === 0) {
                // No data - show placeholder
                dailyChart.data.labels = ['No data yet'];
                dailyChart.data.datasets[0].data = [0];
                dailyChart.update();
                return;
            }

            // Sort by date
            const sortedDates = Object.keys(dailyUsage).sort();
            const values = sortedDates.map(date => dailyUsage[date]);

            dailyChart.data.labels = sortedDates;
            dailyChart.data.datasets[0].data = values;
            dailyChart.update();
        }

        function connectEventStream() {
            const eventsUrl = API_TOKEN
                ? `${API_BASE}/events?token=${encodeURIComponent(API_TOKEN)}`
                : `${API_BASE}/events`;

            eventSource = new EventSource(eventsUrl);

            eventSource.onopen = () => {
                document.getElementById('connectionStatus').classList.remove('disconnected');
                document.getElementById('connectionText').textContent = 'Connected';
            };

            eventSource.onerror = () => {
                document.getElementById('connectionStatus').classList.add('disconnected');
                document.getElementById('connectionText').textContent = 'Connection lost';
                
                // Reconnect after 3 seconds
                setTimeout(() => {
                    if (eventSource) {
                        eventSource.close();
                    }
                    connectEventStream();
                }, 3000);
            };

            eventSource.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('message', data);
                } catch (e) {
                    console.error('Error parsing event:', e);
                }
            });

            eventSource.addEventListener('STATUS', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('STATUS', data);
                    // Update status which may include program changes
                    // This will automatically hide progress if program ends
                    loadInitialData();
                } catch (e) {
                    console.error('Error parsing STATUS event:', e);
                }
            });

            eventSource.addEventListener('EVENT', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('EVENT', data);
                    
                    // Check for ProgramProgress updates
                    if (data.items && Array.isArray(data.items)) {
                        const progressItem = data.items.find(item => 
                            item.key === 'BSH.Common.Option.ProgramProgress'
                        );
                        if (progressItem && progressItem.value !== undefined) {
                            const progressValue = parseInt(progressItem.value);
                            if (!isNaN(progressValue)) {
                                updateProgramProgress(progressValue);
                            }
                        }
                    }
                    
                    loadHistory(); // Reload history
                } catch (e) {
                    console.error('Error parsing EVENT:', e);
                }
            });

            eventSource.addEventListener('NOTIFY', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    addEventToLog('NOTIFY', data);
                    
                    // Check for ProgramProgress updates
                    if (data.items && Array.isArray(data.items)) {
                        const progressItem = data.items.find(item => 
                            item.key === 'BSH.Common.Option.ProgramProgress'
                        );
                        if (progressItem && progressItem.value !== undefined) {
                            const progressValue = parseInt(progressItem.value);
                            if (!isNaN(progressValue)) {
                                updateProgramProgress(progressValue);
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error parsing NOTIFY event:', e);
                }
            });

            eventSource.addEventListener('connected', (event) => {
                const data = JSON.parse(event.data);
                addEventToLog('system', data);
            });
        }

        function addEventToLog(type, data) {
            const eventLog = document.getElementById('eventLog');
            
            // Remove loading message
            if (eventLog.querySelector('.loading') && !eventLog.querySelector('.event-item')) {
                eventLog.innerHTML = '';
            }

            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Extract timestamp from event data
            const { timestamp, timestampValue } = extractTimestamp(data);
            eventItem.setAttribute('data-timestamp', timestampValue);
            
            const eventType = type.toUpperCase();
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(data, null, 2)}</div>
            `;

            // Insert event at correct position (newest first)
            const inserted = insertEventAtPosition(eventItem, timestampValue, data);
            if (!inserted) {
                // Append at end (oldest)
                const loadingIndicator = eventLog.querySelector('.loading-more');
                if (loadingIndicator) {
                    eventLog.insertBefore(eventItem, loadingIndicator);
                } else {
                    eventLog.appendChild(eventItem);
                }
            }

            // Limit to 100 events in DOM (for performance)
            while (eventLog.children.length > 100) {
                const lastChild = eventLog.lastChild;
                if (lastChild && !lastChild.classList.contains('loading-more')) {
                    eventLog.removeChild(lastChild);
                } else {
                    break; // Don't remove more events if loading indicator is reached
                }
            }
        }

        // Cleanup on close
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>

