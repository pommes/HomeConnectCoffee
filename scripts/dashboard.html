<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HomeConnect Coffee Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .version-info {
            position: absolute;
            top: 30px;
            right: 30px;
            font-size: 0.9em;
            opacity: 0.9;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 15px;
            font-weight: 500;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background: #4caf50; /* Green - both connected */
            animation: pulse 2s infinite;
            cursor: help; /* Indicates tooltip is available */
            position: relative;
        }

        .status-indicator.disconnected {
            background: #f44336; /* Red - browser not connected */
            animation: none;
        }

        .status-indicator.api-disconnected {
            background: #ff9800; /* Orange - browser OK, but API not */
            animation: pulse 2s infinite;
        }

        /* Tooltip */
        .status-indicator::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            white-space: pre-line;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            margin-bottom: 5px;
            z-index: 1000;
            text-align: left;
            min-width: 280px;
            max-width: 350px;
        }

        .status-indicator:hover::after {
            opacity: 1;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: #666;
        }

        .status-value {
            font-weight: 600;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .event-log {
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .event-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f9f9f9;
            border-left: 3px solid #667eea;
            border-radius: 3px;
        }

        .event-time {
            color: #999;
            font-size: 0.85em;
        }

        .event-type {
            font-weight: 600;
            color: #667eea;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        /* Progress bar styles */
        .progress-container {
            margin-top: 15px;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .progress-bar-container {
            width: 100%;
            height: 24px;
            background-color: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85em;
        }

        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 0.85em;
            color: #333;
            z-index: 1;
        }

        .progress-bar.active {
            animation: progress-pulse 1.5s ease-in-out infinite;
        }

        @keyframes progress-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>☕ HomeConnect Coffee Dashboard</h1>
            <div class="version-info">{{VERSION}}</div>
            <p>
                <span class="status-indicator" id="connectionStatus"></span>
                <span id="connectionText">Connecting...</span>
            </p>
        </header>

        <div class="grid">
            <div class="card">
                <h2>Live Status</h2>
                <div id="liveStatus">
                    <div class="loading">Loading status...</div>
                </div>
            </div>

            <div class="card">
                <h2>Active Program</h2>
                <div id="activeProgram">
                    <div class="loading">Loading program...</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>API Calls</h2>
                <div id="apiCallsStats">
                    <div class="loading">Loading API statistics...</div>
                </div>
            </div>

            <div class="card">
                <h2>Token Refreshes</h2>
                <div id="tokenRefreshStats">
                    <div class="loading">Loading API statistics...</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Program Statistics</h2>
                <div id="programStatistics">
                    <div class="loading">Loading statistics...</div>
                </div>
            </div>

            <div class="card">
                <h2>Program Usage</h2>
                <div class="chart-container">
                    <canvas id="programChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Daily Usage (last 7 days)</h2>
                <div class="chart-container">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card full-width">
                <h2>Event Log</h2>
                <div class="event-log" id="eventLog">
                    <div class="loading">Waiting for events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = window.location.origin;
        const API_TOKEN = new URLSearchParams(window.location.search).get('token') || '';

        // Charts
        let programChart = null;
        let dailyChart = null;

        // EventSource for live updates
        let eventSource = null;
        // State for API connection status
        let apiStreamConnected = false;
        let lastApiHeartbeat = null;
        
        // Lazy loading state
        let isLoadingMoreEvents = false;
        let hasMoreEvents = true;
        let oldestEventTimestamp = null;

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            setupInfiniteScroll();
            // Initial status (will be updated by STREAM_STATUS event)
            updateConnectionStatus(false, false);
            // Load data - initial data first, then event history
            loadInitialData().then(() => {
                // Load event history after initial data
                loadEventHistory();
            });
            connectEventStream();
            // No setInterval anymore - updates come via event stream
        });

        function initCharts() {
            // Program usage chart (doughnut)
            const programCtx = document.getElementById('programChart').getContext('2d');
            programChart = new Chart(programCtx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Count',
                        data: [],
                        backgroundColor: [
                            'rgba(102, 126, 234, 0.8)',
                            'rgba(118, 75, 162, 0.8)',
                            'rgba(255, 152, 0, 0.8)',
                            'rgba(76, 175, 80, 0.8)',
                            'rgba(244, 67, 54, 0.8)',
                            'rgba(33, 150, 243, 0.8)',
                            'rgba(156, 39, 176, 0.8)',
                            'rgba(255, 193, 7, 0.8)',
                        ],
                        borderColor: [
                            'rgba(102, 126, 234, 1)',
                            'rgba(118, 75, 162, 1)',
                            'rgba(255, 152, 0, 1)',
                            'rgba(76, 175, 80, 1)',
                            'rgba(244, 67, 54, 1)',
                            'rgba(33, 150, 243, 1)',
                            'rgba(156, 39, 176, 1)',
                            'rgba(255, 193, 7, 1)',
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });

            // Daily usage chart
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Usage per day',
                        data: [],
                        borderColor: 'rgba(102, 126, 234, 1)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        async function loadInitialData() {
            // Load API stats first (independent of status)
            try {
                const statsUrl = API_TOKEN 
                    ? `${API_BASE}/api/stats?token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/stats`;
                const statsResponse = await fetch(statsUrl);
                if (statsResponse.ok) {
                    const statsData = await statsResponse.json();
                    updateApiStats(statsData);
                } else {
                    console.error('Error loading API stats:', statsResponse.status, statsResponse.statusText);
                    const apiStatsDiv = document.getElementById('apiStats');
                    if (apiStatsDiv) {
                        apiStatsDiv.innerHTML = `
                            <div class="status-item">
                                <span class="status-value" style="color: #666;">Error loading API statistics</span>
                            </div>
                        `;
                    }
                }
                } catch (statsError) {
                    console.error('Error loading API stats:', statsError);
                    const apiCallsDiv = document.getElementById('apiCallsStats');
                    const tokenRefreshDiv = document.getElementById('tokenRefreshStats');
                    if (apiCallsDiv) {
                        apiCallsDiv.innerHTML = `
                            <div class="status-item">
                                <span class="status-value" style="color: #666;">Error loading</span>
                            </div>
                        `;
                    }
                    if (tokenRefreshDiv) {
                        tokenRefreshDiv.innerHTML = `
                            <div class="status-item">
                                <span class="status-value" style="color: #666;">Error loading</span>
                            </div>
                        `;
                    }
                }

            try {
                // Load status
                const statusUrl = API_TOKEN 
                    ? `${API_BASE}/api/status?token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/status`;
                const statusResponse = await fetch(statusUrl);
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    updateLiveStatus(statusData);
                    // Update API stats from status response if available (may be more up-to-date)
                    if (statusData.api_stats) {
                        updateApiStats(statusData.api_stats);
                    }
                } else {
                    // Handle different error cases
                    const liveStatusDiv = document.getElementById('liveStatus');
                    if (liveStatusDiv && liveStatusDiv.querySelector('.loading')) {
                        if (statusResponse.status === 503 || statusResponse.status === 409) {
                            // Service Unavailable (503) or Conflict (409) - device might be temporarily unavailable
                            // Try to get error details
                            let errorMessage = "Device temporarily unavailable";
                            try {
                                const errorData = await statusResponse.json();
                                if (errorData.error && errorData.error.toLowerCase().includes("offline")) {
                                    errorMessage = "Device offline";
                                }
                            } catch (e) {
                                // Ignore JSON parse errors
                            }
                            liveStatusDiv.innerHTML = `
                                <div class="status-item">
                                    <span class="status-label">Status:</span>
                                    <span class="status-value" style="color: #ff9800;">${errorMessage}</span>
                                </div>
                                <div class="status-item">
                                    <span class="status-label">Operation State:</span>
                                    <span class="status-value">Unreachable</span>
                                </div>
                            `;
                        } else {
                            // Other errors
                            console.error('Error loading status:', statusResponse.status, statusResponse.statusText);
                            liveStatusDiv.innerHTML = `
                                <div class="error">Error loading status (${statusResponse.status})</div>
                            `;
                        }
                    }
                }

                // Load history
                await loadHistory();
            } catch (error) {
                console.error('Error loading data:', error);
                // Show error in UI
                const liveStatusDiv = document.getElementById('liveStatus');
                if (liveStatusDiv) {
                    if (liveStatusDiv.querySelector('.loading')) {
                        liveStatusDiv.innerHTML = `
                            <div class="error">Error loading: ${error.message}</div>
                        `;
                    }
                }
            }
        }

        function formatProgramName(programKey) {
            if (!programKey || programKey === 'No program') {
                return 'No active program';
            }
            
            // Remove common prefixes (in order of specificity, case-insensitive)
            let name = programKey
                .replace(/ConsumerProducts\.CoffeeMaker\.Program\./gi, '')
                .replace(/BSH\.Common\.Program\./gi, '')
                .replace(/CleaningModes\./gi, '')
                .replace(/Beverage\./gi, ''); // Remove Beverage prefix (e.g., "Beverage.Espresso" or "Beverage.espresso")
            
            // Normalize to lowercase for case-insensitive mapping lookup
            const normalizedName = name.toLowerCase();
            
            // Mapping for common program names (case-insensitive lookup)
            const programMap = {
                // Coffee Maker Programs
                'espresso': 'Espresso',
                'coffee': 'Cafè Crema', // Coffee program maps to Cafè Crema
                'cappuccino': 'Cappuccino',
                'lattemacchiato': 'Latte Macchiato',
                'caffelatte': 'Caffè Latte',
                'americano': 'Americano',
                'hotwater': 'Hot Water',
                'hotmilk': 'Hot Milk',
                'milkfoam': 'Milk Foam',
                'ristretto': 'Ristretto',
                'lungo': 'Lungo',
                
                // Cleaning Modes
                'applianceonrinsing': 'Rinsing',
                'applianceondescaling': 'Descaling',
                'applianceoncleaning': 'Cleaning',
                
                // Common States
                'standby': 'Standby',
                'ready': 'Ready',
                'running': 'Running',
                'finished': 'Finished',
                'aborted': 'Aborted',
                'error': 'Error',
            };
            
            // Check if we have a direct mapping (case-insensitive)
            if (programMap[normalizedName]) {
                return programMap[normalizedName];
            }
            
            // Convert camelCase/PascalCase to readable format
            // e.g., "LatteMacchiato" -> "Latte Macchiato"
            name = name.replace(/([A-Z])/g, ' $1').trim();
            
            // Capitalize first letter of each word
            return name.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        function updateLiveStatus(data) {
            const liveStatusDiv = document.getElementById('liveStatus');
            
            // Extract PowerState from settings
            let powerState = 'Unknown';
            let operationState = 'Unknown';
            
            if (data.settings && data.settings.data && data.settings.data.settings) {
                data.settings.data.settings.forEach(setting => {
                    if (setting.key === 'BSH.Common.Setting.PowerState') {
                        powerState = setting.value.replace('BSH.Common.EnumType.PowerState.', '');
                    }
                });
            }
            
            // Extract OperationState from status
            if (data.status && data.status.data && data.status.data.status) {
                data.status.data.status.forEach(status => {
                    if (status.key === 'BSH.Common.Status.OperationState') {
                        operationState = status.value.replace('BSH.Common.EnumType.OperationState.', '');
                    }
                });
            }

            // Create status items
            liveStatusDiv.innerHTML = `
                <div class="status-item">
                    <span class="status-label">Power State:</span>
                    <span class="status-value">${powerState}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Operation State:</span>
                    <span class="status-value">${operationState}</span>
                </div>
            `;

            // Active program
            const activeProgramDiv = document.getElementById('activeProgram');
            if (data.programs && data.programs.active && data.programs.active.data) {
                const program = data.programs.active.data;
                const programKey = program.key || 'No program';
                const programName = formatProgramName(programKey);
                
                // Check for progress in options
                let progressValue = null;
                if (program.options && Array.isArray(program.options)) {
                    const progressOption = program.options.find(opt => 
                        opt.key === 'BSH.Common.Option.ProgramProgress'
                    );
                    if (progressOption && progressOption.value !== undefined) {
                        progressValue = parseInt(progressOption.value);
                    }
                }
                
                let progressHTML = '';
                if (progressValue !== null && progressValue >= 0 && progressValue <= 100) {
                    progressHTML = `
                        <div class="progress-container">
                            <div class="progress-label">
                                <span>Progress</span>
                                <span>${progressValue}%</span>
                            </div>
                            <div class="progress-bar-container">
                                <div class="progress-bar active" style="width: ${progressValue}%"></div>
                                <div class="progress-text">${progressValue}%</div>
                            </div>
                        </div>
                    `;
                }
                
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Program:</span>
                        <span class="status-value">${programName}</span>
                    </div>
                    ${progressHTML}
                `;
            } else {
                // No active program - ensure progress bar is removed
                activeProgramDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Program:</span>
                        <span class="status-value">No active program</span>
                    </div>
                `;
            }

            // Update API statistics if available (already handled in loadInitialData)
            // But also update here in case updateLiveStatus is called from elsewhere
            if (data.api_stats) {
                updateApiStats(data.api_stats);
            }
        }

        function updateApiStats(apiStats) {
            const apiCallsDiv = document.getElementById('apiCallsStats');
            const tokenRefreshDiv = document.getElementById('tokenRefreshStats');
            
            if (!apiStats || Object.keys(apiStats).length === 0) {
                if (apiCallsDiv) {
                    apiCallsDiv.innerHTML = `
                        <div class="status-item">
                            <span class="status-value" style="color: #666;">Not available</span>
                        </div>
                    `;
                }
                if (tokenRefreshDiv) {
                    tokenRefreshDiv.innerHTML = `
                        <div class="status-item">
                            <span class="status-value" style="color: #666;">Not available</span>
                        </div>
                    `;
                }
                return;
            }

            const callsToday = apiStats.calls_today || 0;
            const callsLimit = apiStats.limit || 1000;
            const callsRemaining = apiStats.remaining || 0;
            const callsPercentage = apiStats.percentage || 0;
            const refreshesToday = apiStats.token_refreshes_today || 0;
            const refreshesLimit = apiStats.token_refresh_limit || 100;
            const refreshesRemaining = apiStats.token_refresh_remaining || 100;
            const refreshesPercentage = apiStats.token_refresh_percentage || 0;

            // Determine warning color based on usage
            let callsColor = '#4caf50'; // Green
            if (callsPercentage >= 95) {
                callsColor = '#f44336'; // Red
            } else if (callsPercentage >= 80) {
                callsColor = '#ff9800'; // Orange
            }

            let refreshesColor = '#4caf50'; // Green
            if (refreshesPercentage >= 50) {
                refreshesColor = '#ff9800'; // Orange
            }

            // Calculate background colors for progress bars
            let callsBackground = 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)';
            if (callsColor === '#f44336') {
                callsBackground = '#f44336';
            } else if (callsColor === '#ff9800') {
                callsBackground = '#ff9800';
            }

            let refreshesBackground = 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)';
            if (refreshesColor === '#ff9800') {
                refreshesBackground = '#ff9800';
            }

            // Update API Calls card
            if (apiCallsDiv) {
                apiCallsDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Today:</span>
                        <span class="status-value" style="color: ${callsColor};">
                            ${callsToday}/${callsLimit} (${callsPercentage}%)
                        </span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Remaining:</span>
                        <span class="status-value" style="color: ${callsColor};">
                            ${callsRemaining}
                        </span>
                    </div>
                    <div class="progress-container" style="margin-top: 12px;">
                        <div class="progress-label">
                            <span>Usage</span>
                            <span>${callsPercentage}%</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${callsPercentage}%; background: ${callsBackground};"></div>
                            <div class="progress-text">${callsPercentage}%</div>
                        </div>
                    </div>
                `;
            }

            // Update Token Refreshes card
            if (tokenRefreshDiv) {
                tokenRefreshDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-label">Today:</span>
                        <span class="status-value" style="color: ${refreshesColor};">
                            ${refreshesToday}/${refreshesLimit} (${refreshesPercentage}%)
                        </span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Remaining:</span>
                        <span class="status-value" style="color: ${refreshesColor};">
                            ${refreshesRemaining}
                        </span>
                    </div>
                    <div class="progress-container" style="margin-top: 12px;">
                        <div class="progress-label">
                            <span>Usage</span>
                            <span>${refreshesPercentage}%</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${refreshesPercentage}%; background: ${refreshesBackground};"></div>
                            <div class="progress-text">${refreshesPercentage}%</div>
                        </div>
                    </div>
                `;
            }
        }

        function updateProgramProgress(progressValue) {
            const activeProgramDiv = document.getElementById('activeProgram');
            
            // Check if there's an active program (not "No active program")
            const programItem = activeProgramDiv.querySelector('.status-item');
            if (!programItem) {
                return; // No program item found
            }
            
            const programValueElement = programItem.querySelector('.status-value');
            if (!programValueElement || programValueElement.textContent.trim() === 'No active program') {
                // No active program - remove progress bar if it exists
                const progressContainer = activeProgramDiv.querySelector('.progress-container');
                if (progressContainer) {
                    progressContainer.remove();
                }
                return;
            }
            
            // Validate progress value
            if (progressValue === null || progressValue === undefined || isNaN(progressValue) || progressValue < 0 || progressValue > 100) {
                return;
            }
            
            // Update or create progress display
            let progressContainer = activeProgramDiv.querySelector('.progress-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-container';
                activeProgramDiv.appendChild(progressContainer);
            }
            
            progressContainer.innerHTML = `
                <div class="progress-label">
                    <span>Progress</span>
                    <span>${progressValue}%</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar active" style="width: ${progressValue}%"></div>
                    <div class="progress-text">${progressValue}%</div>
                </div>
            `;
        }

        async function loadHistory() {
            try {
                // Program counts
                const countsUrl = API_TOKEN
                    ? `${API_BASE}/api/history?program_counts=1&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?program_counts=1`;
                const countsResponse = await fetch(countsUrl);
                let programCounts = {};
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    programCounts = countsData.program_counts || {};
                    updateProgramChart(programCounts);
                }

                // Daily usage (7 days for chart)
                const dailyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?daily_usage=1&days=7&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?daily_usage=1&days=7`;
                const dailyResponse = await fetch(dailyUrl);
                let dailyUsage = {};
                if (dailyResponse.ok) {
                    const dailyData = await dailyResponse.json();
                    dailyUsage = dailyData.daily_usage || {};
                    updateDailyChart(dailyUsage);
                }

                // Monthly usage (30 days for statistics)
                const monthlyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?daily_usage=1&days=30&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?daily_usage=1&days=30`;
                const monthlyResponse = await fetch(monthlyUrl);
                let monthlyUsage = {};
                if (monthlyResponse.ok) {
                    const monthlyData = await monthlyResponse.json();
                    monthlyUsage = monthlyData.daily_usage || {};
                }

                // Update statistics with all datasets
                updateProgramStatistics(programCounts, dailyUsage, monthlyUsage);
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        async function loadEventHistory(beforeTimestamp = null) {
            if (isLoadingMoreEvents) {
                return; // Prevent multiple simultaneous loads
            }
            
            try {
                isLoadingMoreEvents = true;
                
                // Load initial 20 events, 20 more when loading more
                const limit = beforeTimestamp ? 20 : 20;
                let historyUrl = API_TOKEN
                    ? `${API_BASE}/api/history?limit=${limit}&token=${encodeURIComponent(API_TOKEN)}`
                    : `${API_BASE}/api/history?limit=${limit}`;
                
                if (beforeTimestamp) {
                    historyUrl += `&before_timestamp=${encodeURIComponent(beforeTimestamp)}`;
                }
                
                const historyResponse = await fetch(historyUrl);
                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    const events = historyData.history || [];
                    
                    const eventLog = document.getElementById('eventLog');
                    
                    // Initial load: clear event log
                    if (!beforeTimestamp) {
                        if (eventLog.querySelector('.loading')) {
                            eventLog.innerHTML = '';
                        }
                        oldestEventTimestamp = null;
                    }
                    
                    if (events.length === 0) {
                        if (!beforeTimestamp) {
                            eventLog.innerHTML = '<div class="loading">No events stored yet</div>';
                        } else {
                            // No more events
                            hasMoreEvents = false;
                            removeLoadingIndicator();
                        }
                    } else {
                        // Events are returned chronologically (oldest first)
                        // For display: newest first (top), so reverse on initial load
                        // When loading more: add events at end (already chronologically sorted)
                        
                        if (!beforeTimestamp) {
                            // Initial load: sort events by timestamp (newest first), then by value if timestamps are equal
                            const sortedEvents = [...events].sort((a, b) => {
                                const timestampA = new Date(a.timestamp).getTime();
                                const timestampB = new Date(b.timestamp).getTime();
                                
                                if (timestampB !== timestampA) {
                                    return timestampB - timestampA; // Descending order (newest first)
                                }
                                
                                // If timestamps are equal, try to sort by value (for ProgramProgress events)
                                const dataA = a.data || {};
                                const dataB = b.data || {};
                                
                                if (dataA.items && dataA.items[0] && dataA.items[0].value !== undefined &&
                                    dataB.items && dataB.items[0] && dataB.items[0].value !== undefined) {
                                    const valueA = parseInt(dataA.items[0].value) || 0;
                                    const valueB = parseInt(dataB.items[0].value) || 0;
                                    return valueB - valueA; // Descending order (higher value first)
                                }
                                
                                return 0; // Maintain insertion order
                            });
                            
                            // Create all event items and insert at once
                            const fragment = document.createDocumentFragment();
                            sortedEvents.forEach(event => {
                                const eventItem = document.createElement('div');
                                eventItem.className = 'event-item';
                                
                                const { timestamp, timestampValue } = extractTimestamp(event.data, event.timestamp);
                                eventItem.setAttribute('data-timestamp', timestampValue);
                                
                                const eventType = (event.type || 'UNKNOWN').toUpperCase();
                                const eventData = event.data || {};
                                
                                eventItem.innerHTML = `
                                    <div class="event-time">${timestamp}</div>
                                    <div class="event-type">${eventType}</div>
                                    <div>${JSON.stringify(eventData, null, 2)}</div>
                                `;
                                
                                fragment.appendChild(eventItem);
                            });
                            
                            eventLog.appendChild(fragment);
                            
                            // Store timestamp of oldest event (for loading more)
                            if (events.length > 0) {
                                // Find oldest event (lowest timestamp)
                                const oldestEvent = events.reduce((oldest, current) => {
                                    const oldestTime = new Date(oldest.timestamp).getTime();
                                    const currentTime = new Date(current.timestamp).getTime();
                                    return currentTime < oldestTime ? current : oldest;
                                });
                                oldestEventTimestamp = oldestEvent.timestamp;
                            }
                        } else {
                            // Load more: add events at end (chronologically oldest first)
                            events.forEach(event => {
                                addEventToLogFromHistory(event, false); // false = add at end
                            });
                            
                            // Update timestamp of oldest loaded event
                            if (events.length > 0) {
                                oldestEventTimestamp = events[0].timestamp;
                            }
                        }
                        
                        
                        // If fewer events than limit were returned, there are no more
                        if (events.length < limit) {
                            hasMoreEvents = false;
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading event history:', error);
            } finally {
                isLoadingMoreEvents = false;
                removeLoadingIndicator();
            }
        }
        
        function setupInfiniteScroll() {
            const eventLog = document.getElementById('eventLog');
            
            eventLog.addEventListener('scroll', () => {
                // Check if user is near the end (100px before end)
                const scrollTop = eventLog.scrollTop;
                const scrollHeight = eventLog.scrollHeight;
                const clientHeight = eventLog.clientHeight;
                
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    // Load more events if there are any
                    if (hasMoreEvents && !isLoadingMoreEvents && oldestEventTimestamp) {
                        showLoadingIndicator();
                        loadEventHistory(oldestEventTimestamp);
                    }
                }
            });
        }
        
        function showLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            // Remove existing loading indicator
            const existing = eventLog.querySelector('.loading-more');
            if (existing) {
                existing.remove();
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading loading-more';
            loadingDiv.textContent = 'Loading more events...';
            eventLog.appendChild(loadingDiv);
        }
        
        function removeLoadingIndicator() {
            const eventLog = document.getElementById('eventLog');
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        // Helper function to format date in local timezone (ISO-like format)
        function formatLocalTimestamp(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // Helper function to extract timestamp from event data
        function extractTimestamp(data, fallbackTimestamp = null) {
            let eventTimestamp = null;
            let timestampValue = Date.now();
            
            if (fallbackTimestamp) {
                // Use provided timestamp (for history events)
                try {
                    eventTimestamp = new Date(fallbackTimestamp);
                    timestampValue = eventTimestamp.getTime();
                } catch (e) {
                    // Invalid timestamp, use current time
                }
            } else if (data && typeof data === 'object') {
                // Extract from data (for live events)
                if (data.timestamp) {
                    if (typeof data.timestamp === 'number') {
                        timestampValue = data.timestamp < 10000000000 ? data.timestamp * 1000 : data.timestamp;
                        eventTimestamp = new Date(timestampValue);
                    } else {
                        eventTimestamp = new Date(data.timestamp);
                        timestampValue = eventTimestamp.getTime();
                    }
                } else if (data.items && Array.isArray(data.items)) {
                    for (const item of data.items) {
                        if (item.timestamp !== undefined && item.timestamp !== null) {
                            timestampValue = parseInt(item.timestamp) * 1000;
                            eventTimestamp = new Date(timestampValue);
                            break;
                        }
                    }
                }
            }
            
            if (!eventTimestamp || isNaN(eventTimestamp.getTime())) {
                eventTimestamp = new Date();
                timestampValue = Date.now();
            }
            
            // Format in local timezone instead of UTC
            const timestamp = formatLocalTimestamp(eventTimestamp);
            return { timestamp, timestampValue };
        }

        // Helper function to compare events for sorting (returns negative if a should come before b)
        function compareEvents(a, b) {
            const timestampA = parseInt(a.getAttribute('data-timestamp') || '0');
            const timestampB = parseInt(b.getAttribute('data-timestamp') || '0');
            
            if (timestampB !== timestampA) {
                return timestampB - timestampA; // Descending order (newest first)
            }
            
            // Same timestamp - try to sort by value (for ProgramProgress events)
            try {
                const lastDivA = a.querySelector('div:last-child');
                const lastDivB = b.querySelector('div:last-child');
                
                if (lastDivA && lastDivB) {
                    const dataA = JSON.parse(lastDivA.textContent);
                    const dataB = JSON.parse(lastDivB.textContent);
                    
                    if (dataA && dataA.items && Array.isArray(dataA.items) && dataA.items[0] && dataA.items[0].value !== undefined &&
                        dataB && dataB.items && Array.isArray(dataB.items) && dataB.items[0] && dataB.items[0].value !== undefined) {
                        const valueA = parseInt(dataA.items[0].value) || 0;
                        const valueB = parseInt(dataB.items[0].value) || 0;
                        return valueB - valueA; // Descending order (higher value first)
                    }
                }
            } catch (e) {
                // If parsing fails, maintain order
            }
            
            return 0; // Maintain insertion order
        }

        // Helper function to insert event at correct position
        function insertEventAtPosition(eventItem, timestampValue, eventData = null) {
            const eventLog = document.getElementById('eventLog');
            const existingEvents = Array.from(eventLog.querySelectorAll('.event-item'));
            
            for (let i = 0; i < existingEvents.length; i++) {
                const existingEvent = existingEvents[i];
                const existingTimestamp = parseInt(existingEvent.getAttribute('data-timestamp') || '0');
                
                if (timestampValue > existingTimestamp) {
                    eventLog.insertBefore(eventItem, existingEvent);
                    return true;
                } else if (timestampValue === existingTimestamp && eventData) {
                    // Same timestamp - try to sort by value
                    try {
                        const lastDivExisting = existingEvent.querySelector('div:last-child');
                        if (lastDivExisting) {
                            const dataExisting = JSON.parse(lastDivExisting.textContent);
                            
                            if (eventData.items && Array.isArray(eventData.items) && eventData.items[0] && eventData.items[0].value !== undefined &&
                                dataExisting && dataExisting.items && Array.isArray(dataExisting.items) && dataExisting.items[0] && dataExisting.items[0].value !== undefined) {
                                const valueNew = parseInt(eventData.items[0].value) || 0;
                                const valueExisting = parseInt(dataExisting.items[0].value) || 0;
                                
                                if (valueNew > valueExisting) {
                                    eventLog.insertBefore(eventItem, existingEvent);
                                    return true;
                                }
                            }
                        }
                    } catch (e) {
                        // If parsing fails, continue
                    }
                }
            }
            
            return false; // Not inserted, should be appended
        }

        function addEventToLogFromHistory(event, prepend = false) {
            const eventLog = document.getElementById('eventLog');
            
            // Remove loading indicator if present
            const loadingDiv = eventLog.querySelector('.loading-more');
            if (loadingDiv) {
                loadingDiv.remove();
            }
            
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Extract timestamp
            const { timestamp, timestampValue } = extractTimestamp(event.data, event.timestamp);
            eventItem.setAttribute('data-timestamp', timestampValue);
            
            const eventType = (event.type || 'UNKNOWN').toUpperCase();
            const eventData = event.data || {};
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(eventData, null, 2)}</div>
            `;

            if (prepend) {
                // Insert at correct position (newest first)
                const inserted = insertEventAtPosition(eventItem, timestampValue, eventData);
                if (!inserted) {
                    // This is the newest event, insert at very top
                    if (eventLog.firstChild) {
                        eventLog.insertBefore(eventItem, eventLog.firstChild);
                    } else {
                        eventLog.appendChild(eventItem);
                    }
                }
            } else {
                // Append at end (for loading more events)
                const loadingIndicator = eventLog.querySelector('.loading-more');
                if (loadingIndicator) {
                    eventLog.insertBefore(eventItem, loadingIndicator);
                } else {
                    eventLog.appendChild(eventItem);
                }
            }
        }

        function updateProgramChart(counts) {
            if (!counts || Object.keys(counts).length === 0) {
                // No data - show placeholder
                programChart.data.labels = ['No data yet'];
                programChart.data.datasets[0].data = [0];
                programChart.update();
                return;
            }

            const labels = Object.keys(counts).map(key => 
                formatProgramName(key)
            );
            const values = Object.values(counts);

            programChart.data.labels = labels;
            programChart.data.datasets[0].data = values;
            programChart.update();
        }

        function updateProgramStatistics(programCounts, dailyUsage, monthlyUsage) {
            const statsDiv = document.getElementById('programStatistics');
            
            if (!programCounts || Object.keys(programCounts).length === 0) {
                statsDiv.innerHTML = `
                    <div class="status-item">
                        <span class="status-value" style="color: #666;">No data yet</span>
                    </div>
                `;
                return;
            }

            // Calculate total count
            const totalCount = Object.values(programCounts).reduce((a, b) => a + b, 0);
            
            // Calculate average per day (last 7 days)
            const dailyValues = Object.values(dailyUsage || {});
            const totalLast7Days = dailyValues.reduce((a, b) => a + b, 0);
            const averagePerDay = dailyValues.length > 0 ? (totalLast7Days / dailyValues.length).toFixed(1) : 0;
            
            // Calculate average per week (last 7 days total)
            const averagePerWeek = totalLast7Days.toFixed(1);
            
            // Calculate average per month (last 30 days total, or extrapolated from 7-day average)
            const monthlyValues = Object.values(monthlyUsage || {});
            const totalLast30Days = monthlyValues.reduce((a, b) => a + b, 0);
            // If we have 30 days of data, use it; otherwise extrapolate from 7-day average
            const averagePerMonth = monthlyValues.length >= 30 
                ? totalLast30Days.toFixed(1)
                : (averagePerDay * 30).toFixed(1);
            
            // Find most used program
            const programEntries = Object.entries(programCounts);
            const mostUsed = programEntries.sort((a, b) => b[1] - a[1])[0];
            const mostUsedName = formatProgramName(mostUsed[0]);
            const mostUsedCount = mostUsed[1];
            
            // Get today's count
            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
            const todayCount = dailyUsage && dailyUsage[today] ? dailyUsage[today] : 0;

            statsDiv.innerHTML = `
                <div class="status-item">
                    <span class="status-label">Total Brewed:</span>
                    <span class="status-value">${totalCount}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Average per Day:</span>
                    <span class="status-value">${averagePerDay}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Average per Week:</span>
                    <span class="status-value">${averagePerWeek}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Average per Month:</span>
                    <span class="status-value">${averagePerMonth}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Most Used:</span>
                    <span class="status-value">${mostUsedName} (${mostUsedCount})</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Today:</span>
                    <span class="status-value">${todayCount}</span>
                </div>
            `;
        }

        function updateDailyChart(dailyUsage) {
            if (!dailyUsage || Object.keys(dailyUsage).length === 0) {
                // No data - show placeholder
                dailyChart.data.labels = ['No data yet'];
                dailyChart.data.datasets[0].data = [0];
                dailyChart.update();
                return;
            }

            // Sort by date
            const sortedDates = Object.keys(dailyUsage).sort();
            const values = sortedDates.map(date => dailyUsage[date]);

            dailyChart.data.labels = sortedDates;
            dailyChart.data.datasets[0].data = values;
            dailyChart.update();
        }

        function updateConnectionStatus(browserConnected, apiConnected) {
            const statusIndicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('connectionText');
            
            // Remove all status classes
            statusIndicator.classList.remove('disconnected', 'api-disconnected');
            
            if (!browserConnected) {
                // Red: Browser not connected
                statusIndicator.classList.add('disconnected');
                statusText.textContent = 'Connection lost';
                statusIndicator.setAttribute('data-tooltip', 
                    'Browser ↔ Server: Disconnected\n' +
                    'Server ↔ API: Unknown\n\n' +
                    'The browser cannot connect to the server. Check your network connection.'
                );
            } else if (!apiConnected) {
                // Orange: Browser OK, but API not
                statusIndicator.classList.add('api-disconnected');
                statusText.textContent = 'Connected (API offline)';
                statusIndicator.setAttribute('data-tooltip',
                    'Browser ↔ Server: Connected ✓\n' +
                    'Server ↔ API: Disconnected ✗\n\n' +
                    'The server is running but cannot connect to HomeConnect API. Events may not be received.'
                );
            } else {
                // Green: Both connected
                statusText.textContent = 'Connected';
                statusIndicator.setAttribute('data-tooltip',
                    'Browser ↔ Server: Connected ✓\n' +
                    'Server ↔ API: Connected ✓\n\n' +
                    'All connections are active. Events are being received.'
                );
            }
        }

        function connectEventStream() {
            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            
            const eventsUrl = API_TOKEN
                ? `${API_BASE}/events?token=${encodeURIComponent(API_TOKEN)}`
                : `${API_BASE}/events`;

            eventSource = new EventSource(eventsUrl);

            eventSource.onopen = () => {
                // Browser connection established - update status with current API state
                updateConnectionStatus(true, apiStreamConnected);
            };

            eventSource.onerror = () => {
                // Browser connection lost - update status
                updateConnectionStatus(false, false);
                
                // Reconnect after 3 seconds
                setTimeout(() => {
                    if (eventSource) {
                        eventSource.close();
                    }
                    connectEventStream();
                }, 3000);
            };

            eventSource.addEventListener('message', (event) => {
                try {
                    console.log('Received message event:', event.data);
                    const data = JSON.parse(event.data);
                    addEventToLog('message', data);
                } catch (e) {
                    console.error('Error parsing event:', e);
                }
            });

            eventSource.addEventListener('STATUS', (event) => {
                try {
                    console.log('Received STATUS event:', event.data);
                    const data = JSON.parse(event.data);
                    addEventToLog('STATUS', data);
                    // Update status which may include program changes
                    // This will automatically hide progress if program ends
                    loadInitialData();
                } catch (e) {
                    console.error('Error parsing STATUS event:', e);
                }
            });

            eventSource.addEventListener('EVENT', (event) => {
                try {
                    console.log('Received EVENT event:', event.data);
                    const data = JSON.parse(event.data);
                    addEventToLog('EVENT', data);
                    
                    // Check for ProgramProgress updates
                    if (data.items && Array.isArray(data.items)) {
                        const progressItem = data.items.find(item => 
                            item.key === 'BSH.Common.Option.ProgramProgress'
                        );
                        if (progressItem && progressItem.value !== undefined) {
                            const progressValue = parseInt(progressItem.value);
                            if (!isNaN(progressValue)) {
                                updateProgramProgress(progressValue);
                            }
                        }
                    }
                    
                    loadHistory(); // Reload history
                } catch (e) {
                    console.error('Error parsing EVENT:', e);
                }
            });

            eventSource.addEventListener('NOTIFY', (event) => {
                try {
                    console.log('Received NOTIFY event:', event.data);
                    const data = JSON.parse(event.data);
                    addEventToLog('NOTIFY', data);
                    
                    // Check for ProgramProgress updates
                    if (data.items && Array.isArray(data.items)) {
                        const progressItem = data.items.find(item => 
                            item.key === 'BSH.Common.Option.ProgramProgress'
                        );
                        if (progressItem && progressItem.value !== undefined) {
                            const progressValue = parseInt(progressItem.value);
                            if (!isNaN(progressValue)) {
                                updateProgramProgress(progressValue);
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error parsing NOTIFY event:', e);
                }
            });

            eventSource.addEventListener('STREAM_STATUS', (event) => {
                try {
                    console.log('Received STREAM_STATUS event:', event.data);
                    const data = JSON.parse(event.data);
                    apiStreamConnected = data.stream_connected || false;
                    lastApiHeartbeat = data.last_heartbeat || null;
                    
                    // Update status based on browser connection (from onopen/onerror)
                    const browserConnected = !document.getElementById('connectionStatus').classList.contains('disconnected');
                    updateConnectionStatus(browserConnected, apiStreamConnected);
                } catch (e) {
                    console.error('Error parsing STREAM_STATUS:', e);
                }
            });

            eventSource.addEventListener('connected', (event) => {
                const data = JSON.parse(event.data);
                addEventToLog('system', data);
            });
        }

        function addEventToLog(type, data) {
            const eventLog = document.getElementById('eventLog');
            
            // Remove loading message
            if (eventLog.querySelector('.loading') && !eventLog.querySelector('.event-item')) {
                eventLog.innerHTML = '';
            }

            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Extract timestamp from event data
            const { timestamp, timestampValue } = extractTimestamp(data);
            eventItem.setAttribute('data-timestamp', timestampValue);
            
            const eventType = type.toUpperCase();
            
            eventItem.innerHTML = `
                <div class="event-time">${timestamp}</div>
                <div class="event-type">${eventType}</div>
                <div>${JSON.stringify(data, null, 2)}</div>
            `;

            // Insert event at correct position (newest first)
            const inserted = insertEventAtPosition(eventItem, timestampValue, data);
            if (!inserted) {
                // Append at end (oldest)
                const loadingIndicator = eventLog.querySelector('.loading-more');
                if (loadingIndicator) {
                    eventLog.insertBefore(eventItem, loadingIndicator);
                } else {
                    eventLog.appendChild(eventItem);
                }
            }

            // Limit to 100 events in DOM (for performance)
            while (eventLog.children.length > 100) {
                const lastChild = eventLog.lastChild;
                if (lastChild && !lastChild.classList.contains('loading-more')) {
                    eventLog.removeChild(lastChild);
                } else {
                    break; // Don't remove more events if loading indicator is reached
                }
            }
        }

        // Cleanup on close
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>

